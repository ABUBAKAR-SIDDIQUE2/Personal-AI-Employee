"""\nWhatsApp Watcher for AI Employee Sensory System\n\nMonitors WhatsApp Web for urgent messages containing specific keywords\nand creates action items for the AI agent to process.\n\nUses Firefox for better compatibility with WhatsApp Web.\n"""\n\nimport time\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import List, Dict, Any, Optional\nimport re\n\ntry:\n    from playwright.sync_api import sync_playwright, Browser, BrowserContext, Page\nexcept ImportError:\n    raise ImportError(\n        "WhatsApp watcher requires Playwright. "\n        "Install with: pip install playwright && playwright install firefox"\n    )\n\nfrom base_watcher import BaseWatcher\n\n\nclass WhatsAppWatcher(BaseWatcher):\n    """\n    Watches WhatsApp Web for urgent messages and creates action items.\n\n    Monitors messages containing keywords: urgent, invoice, payment, help\n    Uses persistent browser context to maintain WhatsApp Web session.\n    Uses Firefox for better WhatsApp Web compatibility.\n    """\n\n    # Keywords to filter urgent messages\n    URGENT_KEYWORDS = ['urgent', 'invoice', 'payment', 'help', 'asap', 'emergency', 'critical']\n\n    def __init__(\n        self,\n        vault_path: str,\n        session_path: str,\n        check_interval: int = 60,\n        headless: bool = True\n    ):\n        """\n        Initialize the WhatsApp watcher.\n\n        Args:\n            vault_path: Path to the AI Employee vault root directory\n            session_path: Path to store browser session data (for persistent login)\n            check_interval: Time in seconds between checks (default: 60)\n            headless: Run browser in headless mode (default: True, but overridden on first run)\n        """\n        super().__init__(vault_path, check_interval)\n\n        self.session_path = Path(session_path)\n\n        # Create session directory if it doesn't exist\n        self.session_path.mkdir(parents=True, exist_ok=True)\n\n        # Check if this is first run (session directory is empty or has no Firefox profile)\n        self.is_first_run = self._is_first_run()\n\n        # Force headless=False on first run to allow QR code scanning\n        if self.is_first_run:\n            self.headless = False\n            self.logger.info("First run detected - forcing visible browser for QR code authentication")\n        else:\n            self.headless = headless\n\n        # Track processed message IDs\n        self.processed_ids_file = self.logs_path / "processed_whatsapp.txt"\n        self.processed_ids = self._load_processed_ids()\n\n        # Playwright instances (initialized on first use)\n        self._playwright = None\n        self._browser = None\n        self._context = None\n        self._page = None\n\n        self.logger.info(f"Initialized WhatsAppWatcher with session at {session_path}")\n        self.logger.info(f"Headless mode: {self.headless}")\n\n    def _is_first_run(self) -> bool:\n        """\n        Check if this is the first run (no existing session).\n\n        Returns:\n            True if first run, False if session exists\n        """\n        # Check if session directory is empty or doesn't contain Firefox profile markers\n        if not self.session_path.exists():\n            return True\n\n        # Check for Firefox profile indicators\n        session_files = list(self.session_path.iterdir())\n\n        # Empty directory = first run\n        if not session_files:\n            return True\n\n        # Check for Firefox-specific files that indicate a valid session\n        firefox_markers = ['prefs.js', 'cookies.sqlite', 'places.sqlite']\n        has_firefox_profile = any(\n            (self.session_path / marker).exists() for marker in firefox_markers\n        )\n\n        return not has_firefox_profile\n\n    def _load_processed_ids(self) -> set:\n        """\n        Load the set of already processed message IDs.\n\n        Returns:\n            Set of processed message ID strings\n        """\n        if self.processed_ids_file.exists():\n            try:\n                with open(self.processed_ids_file, 'r') as f:\n                    return set(line.strip() for line in f if line.strip())\n            except Exception as e:\n                self.logger.warning(f"Could not load processed IDs: {e}")\n                return set()\n        return set()\n\n    def _save_processed_id(self, message_id: str) -> None:\n        """\n        Save a processed message ID to the tracking file.\n\n        Args:\n            message_id: Message identifier to mark as processed\n        """\n        try:\n            with open(self.processed_ids_file, 'a') as f:\n                f.write(f"{message_id}\\n")\n            self.processed_ids.add(message_id)\n        except Exception as e:\n            self.logger.error(f"Could not save processed ID: {e}")\n\n    def _init_browser(self) -> None:\n        """Initialize Playwright browser with persistent context using Firefox."""\n        if self._playwright is None:\n            try:\n                self._playwright = sync_playwright().start()\n\n                # Launch persistent context with Firefox to maintain WhatsApp Web session\n                self._context = self._playwright.firefox.launch_persistent_context(\n                    user_data_dir=str(self.session_path),\n                    headless=self.headless,\n                    viewport={'width': 1280, 'height': 720}\n                )\n\n                # Get the page\n                if len(self._context.pages) > 0:\n                    self._page = self._context.pages[0]\n                else:\n                    self._page = self._context.new_page()\n\n                self.logger.info("Firefox browser initialized successfully")\n\n            except Exception as e:\n                self.logger.error(f"Failed to initialize Firefox browser: {e}")\n                raise\n\n    def _navigate_to_whatsapp(self) -> bool:\n        """\n        Navigate to WhatsApp Web and wait for it to load.\n\n        Returns:\n            True if navigation successful, False otherwise\n        """\n        try:\n            if self._page is None:\n                self._init_browser()\n\n            # Navigate to WhatsApp Web\n            self._page.goto('https://web.whatsapp.com', wait_until='networkidle', timeout=30000)\n\n            # Wait for either QR code or chat list to appear\n            try:\n                # Check if already logged in (chat list appears)\n                self._page.wait_for_selector('[data-testid="chat-list"]', timeout=10000)\n                self.logger.info("WhatsApp Web loaded - already authenticated")\n                return True\n            except:\n                # QR code appeared - need to scan\n                try:\n                    self._page.wait_for_selector('canvas[aria-label*="Scan"]', timeout=5000)\n                    self.logger.warning("QR code detected - please scan to authenticate")\n                    self.logger.warning("Waiting 60 seconds for QR code scan...")\n\n                    # Wait for authentication (chat list appears after scan)\n                    self._page.wait_for_selector('[data-testid="chat-list"]', timeout=60000)\n                    self.logger.info("Authentication successful!")\n                    return True\n                except:\n                    self.logger.error("Failed to authenticate - QR code not scanned in time")\n                    return False\n\n        except Exception as e:\n            self.logger.error(f"Error navigating to WhatsApp Web: {e}")\n            return False\n\n    def check_for_updates(self) -> List[Dict[str, Any]]:\n        """\n        Check WhatsApp Web for new urgent messages.\n\n        Returns:\n            List of message dictionaries with metadata\n        """\n        urgent_messages = []\n\n        try:\n            # Ensure browser is initialized and navigated\n            if not self._navigate_to_whatsapp():\n                self.logger.error("Cannot check for updates - WhatsApp Web not loaded")\n                return []\n\n            # Wait for chat list to be ready\n            self._page.wait_for_selector('[data-testid="chat-list"]', timeout=10000)\n\n            # Find all chats with unread messages\n            # WhatsApp uses spans with aria-label for unread counts\n            unread_chats = self._page.query_selector_all('[aria-label*="unread message"]')\n\n            if not unread_chats:\n                self.logger.debug("No unread messages found")\n                return []\n\n            self.logger.info(f"Found {len(unread_chats)} chat(s) with unread messages")\n\n            # Process each unread chat\n            for chat_element in unread_chats[:10]:  # Limit to 10 chats to prevent overwhelming\n                try:\n                    # Get the parent chat item\n                    chat_item = chat_element.evaluate_handle(\n                        'element => element.closest("[data-testid=\\\\\"cell-frame-container\\\\\"]")' \n                    ).as_element()\n\n                    if not chat_item:\n                        continue\n\n                    # Extract chat name\n                    chat_name_elem = chat_item.query_selector('[data-testid="cell-frame-title"]')\n                    chat_name = chat_name_elem.inner_text() if chat_name_elem else "Unknown"\n\n                    # Extract message preview\n                    message_preview_elem = chat_item.query_selector('[data-testid="last-msg-text"]')\n                    message_preview = message_preview_elem.inner_text() if message_preview_elem else ""\n\n                    # Check if message contains urgent keywords\n                    message_lower = message_preview.lower()\n                    matching_keywords = [kw for kw in self.URGENT_KEYWORDS if kw in message_lower]\n\n                    if not matching_keywords:\n                        self.logger.debug(f"Skipping message from {chat_name} - no urgent keywords")\n                        continue\n\n                    # Create unique message ID\n                    message_id = f"{chat_name}_{message_preview[:50]}_{datetime.now().strftime('%Y%m%d%H%M')}"\n                    message_id = re.sub(r'[^a-zA-Z0-9_]', '_', message_id)\n\n                    # Skip if already processed\n                    if message_id in self.processed_ids:\n                        self.logger.debug(f"Skipping already processed message: {message_id}")\n                        continue\n\n                    # Click on chat to get full message\n                    chat_item.click()\n                    time.sleep(2)  # Wait for messages to load\n\n                    # Get the last few messages from this chat\n                    messages = self._extract_recent_messages()\n\n                    # Create message data\n                    message_data = {\n                        'id': message_id,\n                        'sender': chat_name,\n                        'preview': message_preview,\n                        'full_messages': messages,\n                        'keywords': matching_keywords,\n                        'timestamp': datetime.now()\n                    }\n\n                    urgent_messages.append(message_data)\n                    self.logger.info(f"Found urgent message from {chat_name} with keywords: {matching_keywords}")\n\n                except Exception as e:\n                    self.logger.error(f"Error processing chat: {e}")\n                    continue\n\n        except Exception as e:\n            self.logger.error(f"Error checking for updates: {e}", exc_info=True)\n\n        return urgent_messages\n\n    def _extract_recent_messages(self) -> str:\n        """\n        Extract recent messages from the currently open chat.\n\n        Returns:\n            String containing recent messages\n        """\n        try:\n            # Wait for messages to load\n            self._page.wait_for_selector('[data-testid="msg-container"]', timeout=5000)\n\n            # Get all message containers\n            message_containers = self._page.query_selector_all('[data-testid="msg-container"]')\n\n            # Get last 5 messages\n            recent_messages = []\n            for container in message_containers[-5:]:\n                try:\n                    # Get message text\n                    text_elem = container.query_selector('.copyable-text span')\n                    if text_elem:\n                        message_text = text_elem.inner_text()\n\n                        # Check if incoming or outgoing\n                        is_incoming = container.query_selector('[data-testid="msg-in"]') is not None\n                        prefix = "Them: " if is_incoming else "You: "\n\n                        recent_messages.append(f"{prefix}{message_text}")\n                except:\n                    continue\n\n            return "\\n".join(recent_messages) if recent_messages else "Could not extract messages"\n\n        except Exception as e:\n            self.logger.error(f"Error extracting messages: {e}")\n            return "Error extracting messages"\n\n    def create_action_file(self, item: Dict[str, Any]) -> None:\n        """\n        Create a Markdown action file for an urgent WhatsApp message.\n\n        Args:\n            item: Message data dictionary from check_for_updates()\n        """\n        try:\n            message_id = item['id']\n            sender = item['sender']\n            preview = item['preview']\n            full_messages = item['full_messages']\n            keywords = item['keywords']\n            timestamp = item['timestamp']\n\n            # Generate filename\n            safe_sender = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in sender)\n            safe_sender = safe_sender[:30]  # Limit length\n            filename = f"WHATSAPP_{timestamp.strftime('%Y%m%d_%H%M%S')}_{safe_sender}.md"\n            filepath = self.needs_action_path / filename\n\n            # Create markdown content\n            content = self._generate_whatsapp_markdown(\n                sender=sender,\n                preview=preview,\n                full_messages=full_messages,\n                keywords=keywords,\n                timestamp=timestamp,\n                message_id=message_id\n            )\n\n            # Write file\n            with open(filepath, 'w', encoding='utf-8') as f:\n                f.write(content)\n\n            self.logger.info(f"Created WhatsApp action file: {filename}")\n\n            # Mark as processed\n            self._save_processed_id(message_id)\n\n            # Log the action\n            self.log_action(\n                action="Urgent WhatsApp message detected",\n                details=f"From: {sender} | Keywords: {', '.join(keywords)}"\n            )\n\n        except Exception as e:\n            self.logger.error(f"Error creating action file for message: {e}", exc_info=True)\n            raise\n\n    def _generate_whatsapp_markdown(\n        self,\n        sender: str,\n        preview: str,\n        full_messages: str,\n        keywords: List[str],\n        timestamp: datetime,\n        message_id: str\n    ) -> str:\n        """\n        Generate markdown content for WhatsApp action file.\n\n        Args:\n            sender: Message sender name\n            preview: Message preview text\n            full_messages: Full message conversation\n            keywords: Matched urgent keywords\n            timestamp: Message timestamp\n            message_id: Unique message identifier\n\n        Returns:\n            Formatted markdown string\n        """\n        content = f"""---\ntype: whatsapp\nsender: {sender}\nstatus: pending\npriority: high\nkeywords: {', '.join(keywords)}\nreceived: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}\nmessage_id: {message_id}\n---\n\n# Urgent WhatsApp Message: {sender}\n\n## Message Details\n\n- **From:** {sender}\n- **Received:** {timestamp.strftime('%Y-%m-%d at %H:%M:%S')}\n- **Priority:** High (contains urgent keywords: {', '.join(keywords)})\n- **Status:** Pending\n\n## Preview\n\n{preview}\n\n## Recent Conversation\n\n```\n{full_messages}\n```\n\n## Suggested Actions\n\n- [ ] Reply to sender\n- [ ] Mark as resolved\n- [ ] Forward to relevant party\n- [ ] Add to task list\n- [ ] Schedule follow-up\n\n## Notes\n\nThis message was automatically detected as urgent based on keyword matching.\n\n---\n*Generated by WhatsAppWatcher (Firefox)*\n"""\n        return content\n\n    def __del__(self):\n        """Cleanup browser resources."""\n        try:\n            if self._context:\n                self._context.close()\n            if self._playwright:\n                self._playwright.stop()\n        except:\n            pass\n\n\ndef main():\n    """\n    Main entry point for running the WhatsApp watcher.\n    """\n    import sys\n\n    # Get paths from command line\n    if len(sys.argv) < 2:\n        print("Usage: python whatsapp_watcher.py <session_path> [vault_path] [--headless]")\n        print("  session_path: Directory to store browser session data")\n        print("  vault_path: Path to AI_Employee_Vault (default: current directory)")\n        print("  --headless: Run browser in headless mode (default: visible on first run)")\n        sys.exit(1)\n\n    session_path = sys.argv[1]\n\n    if len(sys.argv) > 2 and not sys.argv[2].startswith('--'):\n        vault_path = sys.argv[2]\n    else:\n        vault_path = Path(__file__).parent\n\n    headless = '--headless' in sys.argv\n\n    # Create and run the watcher\n    try:\n        watcher = WhatsAppWatcher(\n            vault_path=str(vault_path),\n            session_path=session_path,\n            check_interval=60,  # Check every minute\n            headless=headless\n        )\n        print(f"Starting WhatsApp watcher with Firefox...")\n        print(f"Session path: {session_path}")\n        print(f"Monitoring: Urgent messages with keywords: {', '.join(WhatsAppWatcher.URGENT_KEYWORDS)}")\n        print(f"Check interval: 60 seconds")\n        print(f"Headless mode: {watcher.headless}")\n        print(f"Press Ctrl+C to stop")\n\n        if not watcher.headless:\n            print("\\nNote: Browser window will open. If you see a QR code, scan it with your phone.")\n            print("The session will be saved and you won't need to scan again.")\n\n        watcher.run()\n    except KeyboardInterrupt:\n        print("\\nWatcher stopped by user")\n    except Exception as e:\n        print(f"Error: {e}")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)\n\n\nif __name__ == "__main__":\n    main()\n